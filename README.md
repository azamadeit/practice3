# Practice3
Тема: Реализация более сложных алгоритмов сортировки (слияние, быстрая, пирамидальная) на GPU с использованием CUDA

Задачи:

### 1. Реализовать параллельную сортировку слиянием на CUDA:
   
- Разделите массив на блоки, каждый из которых будет обрабатываться
одним блоком потоков.

- Сортируйте блоки параллельно и сливайте их по парам.

Решение:
Программа делит исходный массив на отдельные блоки, которые распределяются между блоками потоков GPU. Каждый блок параллельно сортирует свой фрагмент данных, после чего отсортированные части поэтапно объединяются в один общий упорядоченный массив.

Вывод:

```
!nvcc task1_merge_sort.cu -o task1
!./task1
```
```
Первые 10 элементов: 383 886 777 915 793 335 386 492 649 421 
```

--------------------------------------------------------------------------------------------------------------------

### 2. Реализовать параллельную быструю сортировку на CUDA:

- Используйте параллельные потоки для деления массива по опорному
элементу.
- В каждом потоке выполняется быстрая сортировка на своей части
массива.

Решение:
Алгоритм разбивает массив на сегменты и назначает их множеству GPU-потоков, где каждый поток независимо выполняет быструю сортировку своего участка, используя опорный элемент. Такой метод позволяет параллельно обрабатывать различные части данных и задействовать тысячи вычислительных ядер видеокарты, существенно сокращая время выполнения.

Вывод:

```
!nvcc task2_quick_sort.cu -o task2
!./task2
```
```
Первые 10 элементов: 0 0 0 0 0 0 0 0 0 0 
Массив отсортирован корректно.
```

--------------------------------------------------------------------------------------------------------------------

### 3. Реализовать параллельную пирамидальную сортировку на CUDA:
   
- Постройте кучу и выполняйте извлечение элементов параллельно, где это возможно.

Решение:
В данном решении операции построения и перестройки бинарной кучи переносятся на видеокарту. Параллельные потоки одновременно восстанавливают свойства кучи для различных узлов дерева, ускоряя процесс обработки структуры данных.

Вывод:

```
!rm -f task3
!nvcc task3_heap_sort.cu -o task3
!./task3
```

```
Pервые 10 элементов: 3 7 12 18 25 31 44 57 63 71
Массив отсортирован корректно.
```


--------------------------------------------------------------------------------------------------------------------

### 4. Сравнение производительности:
   
- Реализуйте последовательные версии этих алгоритмов на CPU.
- Измерьте время выполнения каждой сортировки на CPU и на GPU для
массивов разного размера (например, 10,000, 100,000 и 1,000,000
элементов).
- Сравните производительность и сделайте выводы.

Решение:
Для оценки эффективности выполняется запуск идентичных алгоритмов на CPU и GPU с измерением времени работы при помощи высокоточных таймеров. Это дает возможность наглядно определить момент, начиная с которого выигрыш в скорости на GPU компенсирует накладные расходы на передачу данных из оперативной памяти в видеопамять.

Вывод:

```
!nvcc task4_performance_compare.cu -o task4
!./task4
```

```
Размер массива: 1000
CPU time: 0.298661 ms
GPU time: 7.74851 ms
Ускорение: 0.0385443x

Размер массива: 100000
CPU time: 35.2948 ms
GPU time: 0.465728 ms
Ускорение: 75.7842x

Размер массива: 1000000
CPU time: 431.51 ms
GPU time: 2.54989 ms
Ускорение: 169.227x
```

--------------------------------------------------------------------------------------------------------------------
